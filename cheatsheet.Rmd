---
title: "Clean R code cheatsheet"
author: "Ildi Czeller and Jeno Pal"
date: "May 2018"
output:
  html_document:
    df_print: paged
    css: cheatsheet.css
  pdf_document:
    keep_tex: yes
    latex_engine: xelatex
    pandoc_args:
    - -V
    - classoption=twocolumn,a4paper
    - -V
    - geometry=landscape,margin=1cm
    - -V
    - mainfont=Arial
subtitle: Clean code in R workshop, eRum 2018
fontsize: 10pt
---
\pagenumbering{gobble}
\fontsize{12}{22}
\setlength{\parskip}{0pt}
\setlength{\partopsep}{1pt}

<style type="text/css">

body{ /* Normal  */
      font-size: 12px;
  }
td {  /* Table  */
  font-size: 8px;
}
h1.title {
  font-size: 24px;
  color: DarkRed;
}
h1 { /* Header 1 */
  font-size: 20px;
  color: DarkBlue;
}
h2 { /* Header 2 */
    font-size: 16px;
  color: DarkBlue;
}
h3 { /* Header 3 */
  font-size: 14px;
  color: DarkBlue;
}
code.r{ /* Code block */
    font-size: 12px;
}
pre { /* Code block - determines code spacing between lines */
    font-size: 12px;
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval=FALSE)
```

_"One difference between a smart programmer and a professional programmer is that the professional understands that __clarity is king__. Professionals use their powers for good and write code that others can understand."_ (Robert C. Martin: Clean Code)

# 1. Use meaningful names

## Use intent-revealing names

The name should tell you what the object does, how it is used and why it exists.
You don't need a comment to know all these about an object.

```{r, class.source="bg-danger"}
nd <- 3  # number of days
```

```{r, class.source="bg-success"}
number_of_days <- 3
```

## Use names that you can pronounce

```{r, class.source="bg-danger"}
rows_w_miss_val <- df[!complete.cases(df), ]
```

```{r, class.source="bg-success"}
rows_with_missing_values <- df[!complete.cases(df), ]
```

## Use names that are easy to distinguish

Don't use number suffixes of numbers to distinguish variables.

```{r, class.source="bg-danger"}
x1 <- 72.3
x2 <- 34.5
```

```{r, class.source="bg-success"}
latitude <- 72.3
longitude <- 34.5
```

Avoid having close but not the same concepts.

```{r, class.source="bg-danger"}
client_info <- list("id" = 123, "name" = "Foo Ltd.")
client_data <- list("id" = 123, "number_of_clients" = 34353)
```

```{r, class.source="bg-success"}
client <- list("id" = 123, "name" = "Foo Ltd.", "number_of_clients" = 34353)
```

## Use one word for one concept

`get`, `retrieve`, `fetch` are synonyms. Pick one if two functions perform
the same action.

```{r, class.source="bg-danger"}
get_client_data <- function(...)
fetch_location_data <- function(...)
```

```{r, class.source="bg-success"}
get_client_data <- function(...)
get_location_data <- function(...)
```

## Use verbs to name functions

Functions _do_ something with inputs. As such, choose a name that reflects what it
_does_.

```{r, class.source="bg-danger"}
client_data <- function(...)
```

```{r, class.source="bg-success"}
get_client_data <- function(...)
```

## Do not overwrite variables

Otherwise

* it is more difficult to inspect intermediate results
* likely that if you run the same code block twice you will get unintended results

```{r, class.source="bg-danger"}
customers <- delete_rows_with_missing_values(customers)
```

```{r, class.source="bg-success"}
complete_customers <- delete_rows_with_missing_values(customers)
```

## Choose names that do not conflict with base functions or keywords

Find out via calling the Help on the name: `?[name that you want to use]`.
Example: `?data`.

```{r, class.source="bg-danger"}
data <- read_csv("customers.csv")
```

```{r, class.source="bg-success"}
customer_data <- read_csv("customers.csv")
```

## Do not use noise words

? `dt_customers` vs `customers`

<!-- ## Avoid sleng or culture specific words and concepts -->

## Avoid magic numbers

Use named variables instead

# 2. Functions

## Don't repeat yourself (DRY)

Instead, write a function that encapsulates the functionality in one place.

```{r, class.source="bg-danger"}
customers[!complete.cases(customers), ]
locations[!complete.cases(locations), ]
```

```{r, class.source="bg-success"}
get_rows_with_missing_data <- function(df) {
  df[!complete.cases(df), ]
}

get_rows_with_missing_data(customers)
get_rows_with_missing_data(locations)
```

## A function should do precisely one thing

"One thing": things only one level below the abstraction
level of the function name.

If it does more than one things, break it into pieces.

```{r, class.source="bg-danger"}

```

```{r, class.source="bg-success"}
get_rows_with_missing_data <- function(df) {
  df[!complete.cases(df), ]
}

get_rows_with_missing_data(customers)
get_rows_with_missing_data(locations)
```

## Extract code to function to name it

Even if you don't plan to reuse the code in more than one places.

```{r}

```

## Avoid too many parameters (> 3)

If you write a function with too many parameters, write two (or more) functions instead.

## Pass all parameters to a function as arguments

This makes functions self-contained. 

Very rare exception: global constants
with a naming convention that is easy to follow (e.g. `ALL_CAPITAL_LETTERS`).

## Clearly separate functions with side effects and functions with a return value

Save figure vs return figure: create separate functions.

## Organize your functions from top to down in abstraction levels

Main functions should come first, lower level functions that they use come
below them.

# 3. Comments

## Explain with the code itself rather than with comments

```{r, class.source="bg-danger"}
# calculate customer lifetime value
c_ltv <- calc_cust_LTV(cust_data)
```

```{r, class.source="bg-success"}
customer_lifetime_value <- calculate_lifetime_value(customer)
```

# 4. General refactoring tips

## First write a working code, then make it cleaner (= refactor)

## Boy scout rule: if you modify something, think about leaving it a bit cleaner than it was

If you have to touch a piece of code for any reason, consider refactoring it as well.
You may have better sense/ideas of your code later than writing it first even if you
struggled to write clean code in the first place.

## Refactoring is not writing it from scratch again

Small refactors are more effective than complete rewrites.
Guarantees that your code works the same as before and that you can move on
quickly.

## Code should be readable also to people not familiar with R

You don't have to overdo refactoring (dont' create a new function for `dplyr::filter`),
however, hide somewhat cryptic parts to named piece of code (example: `apply(dt, 2, fun)`)

Read code as a book on a high level.

## Scripts should be self-contained

do not require the manual sourcing of another script or libraries

## Remove dead functions, do not leave commendted-out code

# Literature

Robert C. Martin: Clean code.
